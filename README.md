# hot100--note

哈希：

LC49字母异位词：
O(NKlogK) K is the largest string in strs，O(nk)

具体思路，我们可以吧每个字符串转成字符组，然后排序得到一个共同的字符串，然后用Map把所有拥有相同排序字符串的字符串组合起来，然后最后用List加入map的value即可。

***

LC128最长连续序列：

O(N), O(N)

思路：用map或者set给数组去重，因为重复的不考虑，然后遍历map或者set里面的数字，如果包含比此数字小一的数字，那么代表无需重复遍历此数字。如果不包含，那么持续找比此数字大一的数字，然后保存最大的连续上升长度。

***

双指针

LC42接雨水 Hard：

第一种解法，用栈来找出雨水的数量。首先设置栈，设置起始点为0然后遍历height，如果当前高度比栈顶的高度小，那么把当前高度推入栈。如果当前高度比栈顶大，那么弹出栈顶，如果栈里空了，那么代表是边界，不做考虑。如果不为空，那么代表找到有雨水的地方。首先先把弹出栈顶，也就是最低点的高度标记。然后找到现在栈顶和目前高度的最小值，也就是能装雨水的高度。然后找出宽度，也就是当前数标减去栈顶数标再减去一。然后乘起来加入和中。

O(N) 每个长度只会进出栈一次, O(N)栈空间不会超过N

第二种解法：左右指针，设置左右指针，然后保存左右的最大值，开启while循环，先更新最大值，注意边界不能装雨水。更新完最大值以后，如果左指针的最大值小比右指针的最大值小，那么代表左指针的右边有一个高度比左指针左边所有高度都要高，那么就用左指针的最大高度减去当前左指针高度就能得到能接的雨水。同时更新左指针位置反之，如果右指针最大值比左指针小，那么就用右指针最大值减去当前右指针高度即可。同时更新右指针位置。

O（N），O（1）

***

滑动窗口

LC3无重复最长子串

具体思路，用哈希表存入字符下标，用lastIndex来储存滑动窗口左边界，然后滑动右边界，把遍历到的字符下标更新到Map直到滑动到有重复的位置，更新最左边界为最左边界和当前字符前一次出现的地方的最大值。同时一直更新最长长度，直到遍历结束。

O(N), O(26)

***

LC438找到字符串中所有字母异位词

具体思路：创造两个数组哈希表，然后吧p包含的单词和s中p长度包含的单词输入哈希表，然后用Arrays.equals对比两个哈希表，如果相同，那么代表是异位字符串，加入下标。然后从p的长度开始遍历s，用哈希表模拟滑动窗口把新入的加上，减去窗口外的，然后对比两个哈希表，如果相等的话，把下标减去p长度加一加入结果。

O(M + (N - M * 26)), O(26)

***

LC560和为K的子数组

具体思路：前缀和解法，用一个哈希表来存前缀和和数量，先把(0, 1)存入防止第一个数字就满足条件但是找不到前缀。然后遍历数组，把sum加上当前的数字，如果当前数字减去target的值在前缀里面，那么代表找到一个满足的组合。结果加上前缀和数量，然后吧当前sum作为下一个数字的前缀加上。

O(N), O(N)

***

LC76最小覆盖子串

具体思路为：用一个map记录T出现的字符和数量，然后用滑动窗口遍历S，先走右指针，找到满足所有字符出现数量的终点，然后走左指针找到最短满足字符串。然后记录最短字符串，然后设置左指针为下一个字符，继续查找。维护一个need变量来记录还需要找到的字符数量。为了方便维护，所有与T不相关的字符也会被存入map，赋值为-1。

最多扫描两次S，所以时间复杂度为O(N)，空间复杂度为O(K)，K为S和T中的字符数集合。
